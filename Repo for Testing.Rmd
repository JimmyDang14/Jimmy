---
title: "Repo for Testing"
author: "Jimmy DANG"
date: "27 fevrier 2020"
output: html_document
---
rm(list = ls())



 Applications of Random walk - Bacteria Motility

# load packages
library(plotrix)
library(emojifont)
library(pracma)
library(circular)
library(GoFKernel)
kappa = c*inverse(norm(c(xt,yt), type = "2"))

# define fct update position
update_position = function(x1,y1){
  # generate an angle
  angle = rvonmises(n, mu, kappa, control.circular=list())
  speed = runif(1, 0, 2)
  x2 = x1 + speed*cos(angle)
  y2 = y1 + speed*sin(angle)
  return(c(x2,y2))
}
#Divers 
n=100
c=100
xs=0
ys=0
#to get mu (jimmy)
compute_angle = function(xt, yt, xs, ys){
   if(yt>0){
     angle = -(pi - atan2(yt, xt))
   }
  else{
    angle = pi + atan2(yt, xt)
  }
  angle
}
#Examples
compute_angle(1,1,0,0)
compute_angle(1,-1,0,0)

---------------------------------------------
read.csv("C:/Utilisateurs/Soajin14/Documents/Nombre de supermarch?s chaque commune.xlsx", header = TRUE, sep = ",")
-----------------------------------------------
# Applications of Random walk - Bacteria Motility

# load packages
library(plotrix)
#install.packages("emojifont")
library(emojifont)

# define fct update position
update_position = function(x1,y1){
  # generate an angle
  angle = runif(1,0,2*pi)
  speed = runif(1, 0, 2)
  x2 = x1 + speed*cos(angle)
  y2 = y1 + speed*sin(angle)
  return(c(x2,y2))
}

# define fct identify_furthest_point_in_circle
identify_furthest_point_in_circle = function(x1,y1,x2,y2, circle_x, circle_y, radius){
  # check if initial position is in the center
  euclidean_norm_init_pos = norm(c(x1-circle_x,y1-circle_y), type = "2")
  # check if initial position is in the circle
  if(euclidean_norm_init_pos >= radius){
    return(c(x2, y2))
    # if was in the circle, return max point in the circle
  }else if(euclidean_norm_init_pos < radius){
    direction_line = approx(x= c(x1,x2), y = c(y1,y2), n = 100)
    
    # find the last point in the line that respect the circle constraint
    
    if(x1 > x2){
      mat_of_traj = cbind(rev(direction_line$x), rev(direction_line$y))
      
    }else{mat_of_traj = cbind( direction_line$x, direction_line$y)}
    
    vec_of_norms = sqrt(mat_of_traj[,1]^2 + mat_of_traj[,2]^2)
    mat_of_traj = cbind(mat_of_traj, vec_of_norms)
    index_last_pt = max(which(mat_of_traj[,3]<radius))
    last_pos_in_circle = c(mat_of_traj[index_last_pt,1],  mat_of_traj[index_last_pt,2])
    
    # return last position in circle
    return(last_pos_in_circle) 
  }
}

# define fct check_position
check_position = function(x1,y1,x2,y2, circle_x, circle_y, radius){
  # check if initial position is in the center
  euclidean_norm_init_pos = norm(c(x1-circle_x,y1-circle_y), type = "2")
  # check if initial position is in the circle
  if(euclidean_norm_init_pos >= radius){
    return(c(x2, y2))
    # if was in the circle, return the initial position
  }else if(euclidean_norm_init_pos < radius){
    return(c(x1, y1)) 
  }
}

# define color palette
gg_color_hue <- function(n, alpha = 1) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100, alpha = alpha)[1:n]
}

# define circle coordinate
circle_coor_x = 0
circle_coor_y = 0
circle_radius = 3


# select if you stop once in the section of sugar or if the bacteria continues moving in it
move_in_sugar = T

# define number of bacteria
N = 20

# define number of steps
M = 150


# define colors
color_pal = gg_color_hue(n=N, alpha = 0.4)

# create a matrix of initial values
# define the first position as uniform
set.seed(123)
current_position_mat = matrix(data = runif(N*2, min = -9, max = 9), ncol = 2, nrow = N)

# create array of all position
all_position = array(NA, dim = c(N, 2, M+1))
all_position[,,1] = current_position_mat

# compute all trajectories
for(step in seq(M)){
  for(bacteria_i in seq(N)){
    current_pos = current_position_mat[bacteria_i,]
    new_pos = update_position(current_pos[1], current_pos[2])
    # check last position in circle if already in the circle
    # if bacteria keeps moving in sugar
    if(move_in_sugar == T){
      new_pos_verified = identify_furthest_point_in_circle(x1 = current_pos[1],
                                                           y1 = current_pos[2],
                                                           x2 = new_pos[1],
                                                           y2 = new_pos[2],
                                                           circle_x = circle_coor_x,
                                                           circle_y = circle_coor_y,
                                                           radius = circle_radius)
    # if bacteria do not keep moving in sugar
    }else if(move_in_sugar == F){
      new_pos_verified = check_position(x1 = current_pos[1],
                                        y1 = current_pos[2],
                                        x2 = new_pos[1],
                                        y2 = new_pos[2],
                                        circle_x = circle_coor_x,
                                        circle_y = circle_coor_y,
                                        radius = circle_radius)
      
    }
    all_position[bacteria_i,,step + 1] = c(new_pos_verified)
    current_position_mat[bacteria_i,] = new_pos_verified
  }
}
# Compute an animation of the path of the bacterias
for(step in seq(M)){
  # plot now all of the trajectories with the point each time
  # plot the map
  plot(NA, ylim = c(-10,10), xlim = c(-10,10), asp =1, 
       xlab = "X Position", ylab = "Y Position", main = "Bacteria Motility")
  grid(lty="solid")
  
  
  # define circle coordinate
  circle_coor_x = 0
  circle_coor_y = 0
  circle_radius = 3
  
  # add circle of sugar
  draw.circle(x = circle_coor_x, y = circle_coor_y, radius = circle_radius, col = "orange")
  
  # add legend of sugar
  text(x=0, y=0, "SUGAR", col="white", cex = 1.5)
  
  for(bacteria_i in seq(N)){
    #points(x = all_position[bacteria_i,1,step], y = all_position[bacteria_i,2,step],  col = 1, pch = 16  )
    text(x = all_position[bacteria_i,1,step], y = all_position[bacteria_i,2,step], labels=emoji('alien'), cex=1.75, family='EmojiOne')
    lines(x = all_position[bacteria_i, 1, 1:step], y = all_position[bacteria_i, 2, 1:step], col =  color_pal[bacteria_i] )
  }
  Sys.sleep(.7)
  
}
